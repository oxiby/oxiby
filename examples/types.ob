use self E.U, E.T, E.S -> St

struct S {
    a: String,
    b: String,
}

struct GenS<a, b> {
    a: a,
    b: b,
}

enum E {
    U,
    T(String, String),
    S {
      c: String,
      d: String,
    },
}

enum GenE<a, b, c, d> {
    U,
    T(a, b),
    S {
        c: c,
        d: d,
    },
}

trait Empty {}

trait OneGeneric<t> {}

trait Child where Self ^ Empty {}

trait ConstrainedGeneric<t> where t ^ Empty {}

trait OneAssoc {
    type a

    pub fn test() -> a
}

impl Empty for S {}

impl OneGeneric<e> for S {}

impl Child for S {}

impl ConstrainedGeneric<e> for S {}

impl OneAssoc for S {
    type a = String

    pub fn test() -> a {
      "test"
    }
}

fn main() {
    let s = S {
      a = "a",
      b = "b",
    }

    let unit = E.U
    let tuple = E.T("1", "2")
    let strct = E.S {
      c = "c",
      d = "d",
    }

    let assoc = S.test()

    let x = match tuple {
      E.U -> "unit",
      E.T(x, y) -> "tuple: 0=#{x}, 1=#{y}",
      E.S { c, d -> x } -> "struct: c=#{c}, d=#{x}",
    }

    let y = match tuple {
      U -> "unit",
      T(x, y) -> "tuple: 0=#{x}, 1=#{y}",
      St { c, d -> x } -> "struct: c=#{c}, d=#{x}",
    }
}
